<!DOCTYPE html>
<html lang="ru">
<head>
    <title>{{ title }}</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://mapgl.2gis.com/api/js/v1"></script> 
    <style>
        html, body, #map { margin: 0; padding: 0; width: 100%; height: 100vh; overflow: hidden; }
        .info-box { 
            position: absolute; top: 10px; left: 10px; 
            background: rgba(20, 25, 35, 0.95); 
            padding: 15px; border-radius: 8px; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.4); 
            z-index: 1000; max-width: 380px; 
            font-family: 'Segoe UI', sans-serif; font-size: 13px; 
            color: #e0e0e0; max-height: calc(100% - 40px); overflow-y: auto;
            border: 1px solid rgba(100, 150, 255, 0.3);
        }
        .info-box h3 { color: #4a9eff; margin: 0 0 10px 0; font-size: 16px; }
        .info-box ul { list-style-type: none; padding-left: 0; margin: 5px 0; }
        .info-box li { padding: 2px 0; }
        .info-box p { margin: 8px 0; }
        .info-box b { color: #7ab8ff; }
        .controls-section { margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(100, 150, 255, 0.2); }
        .button-group { display: flex; gap: 8px; margin-bottom: 10px; flex-wrap: wrap; }
        .button-group button { 
            padding: 8px 14px; font-size: 13px; border: none; border-radius: 6px; 
            background: linear-gradient(135deg, #0066cc, #0088ff); 
            color: white; cursor: pointer; 
            box-shadow: 0 2px 8px rgba(0, 100, 255, 0.3);
            transition: all 0.2s ease;
        }
        .button-group button:hover { 
            background: linear-gradient(135deg, #0077dd, #0099ff);
            transform: translateY(-1px);
        }
        .button-group button:disabled { background: #444; cursor: not-allowed; }
        .signal-bar { 
            height: 8px; background: #333; border-radius: 4px; overflow: hidden; margin-top: 5px;
        }
        .signal-fill { 
            height: 100%; background: linear-gradient(90deg, #00cc66, #66ff99); 
            transition: width 0.3s ease;
        }
        .status-connected { color: #00cc66; }
        .status-disconnected { color: #ff4444; }
        .status-connecting { color: #ffaa00; }
        .telemetry-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
        .telemetry-item { background: rgba(255,255,255,0.05); padding: 8px; border-radius: 4px; }
        .telemetry-value { font-size: 16px; font-weight: bold; color: #4a9eff; }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="info-box">
        <h3>üöÅ UAV Navigation System</h3>
        <p><b>Instructions:</b></p>
        <ol style="margin: 5px 0; padding-left: 20px; font-size: 12px;">
            <li><b>Select Starting Point (Point A):</b> Choose a location from the dropdown above. Click "Set Starting Point" to confirm.</li>
            <li><b>Set Destination (Point B):</b> Click anywhere on the map to set your destination.</li>
            <li><b>Watch the Flight:</b> The drone will follow the calculated route accurately from Point A to Point B.</li>
        </ol>
        <p style="font-size: 11px; color: #aaa; margin-top: 8px;"><i>The UAV position is calculated via trilateration from LTE base stations for precise navigation.</i></p>
        
        <div class="controls-section">
            <b>Server Status:</b> <span id="server_status" class="status-connecting">Connecting...</span>
        </div>
        
        <div class="controls-section">
            <b>üìç Select Starting Point (Point A):</b>
            <p style="font-size: 11px; color: #aaa; margin: 5px 0;">Choose a starting location from the list below. This will be your drone's initial position (Point A).</p>
            <select id="startLocationSelect" style="width: 100%; padding: 8px; margin-top: 5px; background: rgba(255,255,255,0.1); border: 1px solid rgba(100, 150, 255, 0.3); border-radius: 4px; color: #e0e0e0; font-size: 13px;">
                <option value="">-- Select Starting Location --</option>
            </select>
            <button id="setStartLocationButton" style="width: 100%; margin-top: 8px; padding: 8px; font-size: 13px; border: none; border-radius: 6px; background: linear-gradient(135deg, #00aa44, #00cc66); color: white; cursor: pointer; box-shadow: 0 2px 8px rgba(0, 200, 100, 0.3); transition: all 0.2s ease;" disabled>Set Starting Point</button>
            <p id="selectedStartLocation" style="font-size: 11px; color: #4a9eff; margin: 5px 0; font-style: italic;"></p>
        </div>
        
        <div class="controls-section">
            <b>LTE Signal Quality:</b>
            <div class="signal-bar"><div class="signal-fill" id="signal_bar" style="width: 0%"></div></div>
        </div>
        
        <div class="controls-section button-group">
            <button id="startDemoButton">Start Demo</button>
            <button id="resetButton">Reset Route</button>
            <button id="toggleStationsButton">Hide Stations</button>
        </div>
        
        <div class="telemetry-grid">
            <div class="telemetry-item">
                <div>UAV Position (A)</div>
                <div class="telemetry-value" id="pointA_coords">Waiting...</div>
            </div>
            <div class="telemetry-item">
                <div>Destination (B)</div>
                <div class="telemetry-value" id="pointB_coords">Not set</div>
            </div>
        </div>
        
        <div class="controls-section">
            <p><b>Active Base Stations:</b> <span id="active_stations">-</span></p>
            <p><b>Base Stations:</b></p>
            <ul id="stations_list"></ul>
        </div>
        
        <p><b>Route Length:</b> <span id="route_length">0 m</span></p>
        <p><b>Intersection Points:</b> <span id="intersection_count">0</span></p>
        <ul id="intersection_points_list"></ul>
        <p><b>Route Instructions:</b></p>
        <ul id="maneuvers_list"><li>No route</li></ul>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const stationsData = JSON.parse('{{ stations | tojson | safe }}');
            const twoGisApiKey = JSON.parse('{{ two_gis_api_key | tojson | safe }}');
            const initialCenterLat = JSON.parse('{{ initial_center_lat | tojson | safe }}');
            const initialCenterLon = JSON.parse('{{ initial_center_lon | tojson | safe }}');
            const initialZoom = JSON.parse('{{ initial_zoom | tojson | safe }}');
            const droneLocations = JSON.parse('{{ drone_locations | tojson | safe }}');
            
            // Wait for mapgl library to load
            function waitForMapgl(callback, maxAttempts = 50) {
                if (typeof mapgl !== 'undefined' && mapgl.Map) {
                    callback();
                } else if (maxAttempts > 0) {
                    setTimeout(() => waitForMapgl(callback, maxAttempts - 1), 100);
                } else {
                    alert("Map initialization error: 2GIS mapgl library failed to load. Please check your internet connection and refresh the page.");
                }
            }
            
            waitForMapgl(() => {
                if (!twoGisApiKey || twoGisApiKey.trim() === '') {
                    alert("Map initialization error: API key is missing or invalid.");
                    return;
                }
                
                let map;
                try {
                    console.log('Initializing map with center:', initialCenterLat, initialCenterLon);
                    map = new mapgl.Map('map', { 
                        center: [initialCenterLon, initialCenterLat], 
                        zoom: initialZoom, 
                        key: twoGisApiKey 
                    });
                    console.log('Map initialized successfully');
                    
                    // Add map load event listener
                    map.on('load', () => {
                        console.log('Map loaded and ready');
                    });
                } catch (error) {
                    alert("Map initialization error: " + error.message);
                    console.error("Map initialization error:", error);
                    return;
                }
                
                const operatorColors = {
                    'MTS': '#e60000', 'Beeline': '#ffdd00', 
                    'Megafon': '#00b550', 'Tele2': '#1f1f1f', 'default': '#808080'
                };
                
                let droneLocation = null, endPoint = null, droneMarker = null, endMarker = null, routeLine = null;
                let stationMarkers = [], stationCircles = [], stationsVisible = true;
                let intersectionMarkers = [], warningCircles = [], currentRouteWaypoints = [];
                let socket = null;
                let selectedStationIds = new Set();  // Track selected station IDs for display
                
                // DOM elements
                const resetButton = document.getElementById('resetButton');
                const startDemoButton = document.getElementById('startDemoButton');
                const toggleStationsButton = document.getElementById('toggleStationsButton');
                const startLocationSelect = document.getElementById('startLocationSelect');
                const setStartLocationButton = document.getElementById('setStartLocationButton');
                const selectedStartLocation = document.getElementById('selectedStartLocation');
                const pointA_coords = document.getElementById('pointA_coords');
                const pointB_coords = document.getElementById('pointB_coords');
                const route_length_span = document.getElementById('route_length');
                const maneuvers_list = document.getElementById('maneuvers_list');
                const intersection_count_span = document.getElementById('intersection_count');
                const intersection_points_list = document.getElementById('intersection_points_list');
                const server_status_span = document.getElementById('server_status');
                const stations_list_elem = document.getElementById('stations_list');
                const signal_bar = document.getElementById('signal_bar');
                const active_stations = document.getElementById('active_stations');
                
                // Populate starting location dropdown
                if (droneLocations && Array.isArray(droneLocations)) {
                    droneLocations.forEach(loc => {
                        const option = document.createElement('option');
                        option.value = loc.id;
                        option.textContent = `${loc.name} - ${loc.description}`;
                        startLocationSelect.appendChild(option);
                    });
                }
                
                // Enable/disable set button based on selection
                startLocationSelect.addEventListener('change', () => {
                    setStartLocationButton.disabled = !startLocationSelect.value;
                });
                
                // Set starting location
                setStartLocationButton.addEventListener('click', () => {
                    const locationId = startLocationSelect.value;
                    if (locationId && socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({
                            type: 'set_start_location',
                            payload: { location_id: locationId }
                        }));
                        const selectedLoc = droneLocations.find(loc => loc.id === locationId);
                        if (selectedLoc) {
                            selectedStartLocation.textContent = `‚úì Selected: ${selectedLoc.name}`;
                            // Update point A display
                            pointA_coords.textContent = `${selectedLoc.lat.toFixed(4)}, ${selectedLoc.lon.toFixed(4)}`;
                            // Update drone marker if it exists
                            if (droneLocation) {
                                updateDroneLocation(selectedLoc.lat, selectedLoc.lon, 100, [], []);
                            } else {
                                // Create drone marker at selected location
                                if (droneMarker) droneMarker.destroy();
                                droneMarker = new mapgl.Marker(map, {
                                    coordinates: [selectedLoc.lon, selectedLoc.lat],
                                    icon: './icons/drone.png',
                                    size: [48, 48]
                                });
                                map.setCenter([selectedLoc.lon, selectedLoc.lat], { duration: 500 });
                            }
                            console.log(`Starting location set to: ${selectedLoc.name}`);
                        }
                    } else if (!socket || socket.readyState !== WebSocket.OPEN) {
                        alert('WebSocket not connected. Please wait for connection and try again.');
                    }
                });
                
                // Utility functions
                function toRadians(d) { return d * Math.PI / 180; }
                
                function calculateDistanceMeters(lat1, lon1, lat2, lon2) { 
                    const R = 6371000;
                    const dLat = toRadians(lat2 - lat1);
                    const dLon = toRadians(lon2 - lon1);
                    const a = Math.sin(dLat / 2)**2 + Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) * Math.sin(dLon / 2)**2;
                    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                }
                
                function isPointInCircle(pLat, pLon, cLat, cLon, cRad) { 
                    return calculateDistanceMeters(pLat, pLon, cLat, cLon) <= cRad; 
                }
                
                const STATION_VISIBILITY_RADIUS = 150; // meters
                
                function renderStationsNearDrone() { 
                    stationMarkers.forEach(m => m.destroy()); 
                    stationCircles.forEach(c => c.destroy()); 
                    stationMarkers = []; 
                    stationCircles = []; 
                    stations_list_elem.innerHTML = ''; 
                    
                    // Only show selected stations (up to MAX_TOWERS_TO_SELECT = 7)
                    // Filter stations to only include those in selectedStationIds
                    const stationsToShow = stationsData.filter(s => selectedStationIds.has(s.id));
                    
                    // If no selected stations yet, show nearby stations (fallback for initial state)
                    const stationsToDisplay = stationsToShow.length > 0 
                        ? stationsToShow 
                        : (droneLocation 
                            ? stationsData.filter(s => calculateDistanceMeters(droneLocation.lat, droneLocation.lon, s.lat, s.lon) <= STATION_VISIBILITY_RADIUS)
                            : []);
                    
                    stationsToDisplay.forEach(s => { 
                        const color = operatorColors[s.operator] || operatorColors['default']; 
                        // Highlight selected stations with a different style
                        const isSelected = selectedStationIds.has(s.id);
                        const markerLabel = isSelected 
                            ? `üì° ${s.id} (${s.operator}) ‚≠ê` 
                            : `üì° ${s.id} (${s.operator})`;
                        
                        stationMarkers.push(new mapgl.Marker(map, { 
                            coordinates: [s.lon, s.lat], 
                            label: { text: markerLabel, color: color, fontSize: 12, stroke: 'white' } 
                        })); 
                        stationCircles.push(new mapgl.Circle(map, { 
                            coordinates: [s.lon, s.lat], 
                            radius: s.radius, 
                            color: isSelected ? 'rgba(100, 255, 100, 0.15)' : 'rgba(100, 150, 255, 0.1)', 
                            stroke: color, 
                            strokeWidth: isSelected ? 3 : 2,  // Thicker stroke for selected stations
                            interactive: false 
                        })); 
                        const li = document.createElement('li'); 
                        const selectedIndicator = isSelected ? ' ‚≠ê SELECTED' : '';
                        li.innerHTML = `<span style="color: ${color}; font-weight: ${isSelected ? 'bold' : 'normal'};};">‚óè</span> ID ${s.id} (${s.operator}) - ${s.radius}m${selectedIndicator}`; 
                        stations_list_elem.appendChild(li); 
                    }); 
                    toggleStationsButton.textContent = 'Hide Stations'; 
                }
                
                function renderRouteLine(coords) { 
                    if (routeLine) {
                        try {
                            routeLine.destroy(); 
                        } catch (e) {
                            // Ignore errors when destroying
                        }
                    }
                    routeLine = null;
                    
                    // FIXED: Ensure route line is always rendered, even for small routes
                    if (coords && Array.isArray(coords) && coords.length >= 2) {
                        // Validate coordinates
                        const validCoords = coords.filter(c => 
                            Array.isArray(c) && 
                            c.length >= 2 && 
                            typeof c[0] === 'number' && 
                            typeof c[1] === 'number' &&
                            !isNaN(c[0]) && 
                            !isNaN(c[1])
                        );
                        
                        if (validCoords.length < 2) {
                            console.warn('Not enough valid coordinates to render route line');
                            return;
                        }
                        
                        try {
                            // For very long routes, sample coordinates to prevent performance issues
                            let coordsToRender = validCoords;
                            if (validCoords.length > 1000) {
                                const step = Math.ceil(validCoords.length / 1000);
                                coordsToRender = validCoords.filter((_, i) => i % step === 0 || i === validCoords.length - 1);
                                console.log(`Route simplified from ${validCoords.length} to ${coordsToRender.length} points for rendering`);
                            }
                            
                            routeLine = new mapgl.Polyline(map, { 
                                coordinates: coordsToRender, 
                                width: 5, 
                                color: '#00aaff',
                                dashArray: [10, 5]
                            }); 
                            console.log(`Route line rendered with ${coordsToRender.length} points`);
                        } catch (error) {
                            console.error('Error rendering route line:', error);
                            // Try with even fewer points as fallback
                            if (validCoords.length > 10) {
                                const step = Math.ceil(validCoords.length / 50);
                                const sampled = validCoords.filter((_, i) => i % step === 0 || i === validCoords.length - 1);
                                try {
                                    routeLine = new mapgl.Polyline(map, { 
                                        coordinates: sampled, 
                                        width: 5, 
                                        color: '#00aaff',
                                        dashArray: [10, 5]
                                    }); 
                                    console.log(`Route line rendered with fallback sampling: ${sampled.length} points`);
                                } catch (fallbackError) {
                                    console.error('Fallback route rendering also failed:', fallbackError);
                                }
                            }
                        }
                    } else {
                        console.warn('Invalid coordinates for route line:', coords);
                    }
                }
                
                function renderManeuvers(maneuvers) { 
                    maneuvers_list.innerHTML = maneuvers?.length 
                        ? maneuvers.map(m => `<li>‚û§ ${m.comment}</li>`).join('') 
                        : '<li>No route</li>'; 
                }
                
                function analyzeRouteForIntersections(routePoints, stations) { 
                    const results = []; 
                    routePoints.forEach(p => { 
                        const coveredBy = stations.filter(s => isPointInCircle(p.lat, p.lon, s.lat, s.lon, s.radius)).map(s => s.id); 
                        if (coveredBy.length > 1) results.push({ ...p, covered_by: coveredBy }); 
                    }); 
                    return results; 
                }
                
                function renderIntersectionPoints(points) { 
                    intersectionMarkers.forEach(m => m.destroy()); 
                    intersectionMarkers = points.map(p => new mapgl.Circle(map, { 
                        coordinates: [p.lon, p.lat], 
                        radius: 8, 
                        color: 'rgba(0, 255, 100, 0.7)' 
                    })); 
                    intersection_count_span.textContent = points.length; 
                    intersection_points_list.innerHTML = points.length 
                        ? points.map(p => `<li>(${p.lat.toFixed(4)}, ${p.lon.toFixed(4)}) - Stations: [${p.covered_by.join(',')}]</li>`).join('') 
                        : ''; 
                }
                
                async function fetchRoute(start, finish) { 
                    try { 
                        const res = await fetch(`https://routing.api.2gis.com/routing/7.0.0/global?key=${twoGisApiKey}`, { 
                            method: "POST", 
                            headers: { "Content-Type": "application/json" }, 
                            body: JSON.stringify({ 
                                points: [{ lon: start.lon, lat: start.lat }, { lon: finish.lon, lat: finish.lat }], 
                                transport: "driving", 
                                output: "detailed" 
                            }) 
                        }); 
                        
                        if (!res.ok) { 
                            const err = await res.json().catch(() => null); 
                            throw new Error(err?.error?.message || `HTTP ${res.status}`); 
                        } 
                        
                        const parsed = await res.json(); 
                        if (!parsed?.result?.[0]) throw new Error("API returned empty result."); 
                        
                        const routeData = parsed.result[0]; 
                        const coords = routeData.maneuvers.flatMap(m => 
                            m.outcoming_path?.geometry?.flatMap(g => 
                                g.selection.replace(/LINESTRING\(|\)/g, "").split(',').map(pStr => { 
                                    const p = pStr.trim().split(" ").map(Number); 
                                    return (p.length === 2 && !isNaN(p[0])) ? { lon: p[0], lat: p[1] } : null; 
                                }).filter(Boolean)
                            ) || []
                        ); 
                        
                        if (coords.length > 0) { 
                            currentRouteWaypoints = coords;
                            
                            // FIXED: Always render route line, even for small routes
                            const routeCoords = coords.map(c => {
                                // Validate coordinate format
                                if (c && typeof c.lon === 'number' && typeof c.lat === 'number' && 
                                    !isNaN(c.lon) && !isNaN(c.lat)) {
                                    return [c.lon, c.lat];
                                }
                                return null;
                            }).filter(c => c !== null);
                            
                            if (routeCoords.length >= 2) {
                                renderRouteLine(routeCoords);
                            } else {
                                console.error('Not enough valid coordinates after filtering');
                                alert('Error: Route coordinates are invalid. Please try selecting a different destination.');
                                return;
                            }
                            
                            renderManeuvers(routeData.maneuvers); 
                            route_length_span.textContent = `${(routeData.total_distance / 1000).toFixed(2)} km`; 
                            renderIntersectionPoints(analyzeRouteForIntersections(coords, stationsData)); 
                            
                            // Send route to server for drone navigation
                            // This will update the route even if drone is currently flying
                            if (socket && socket.readyState === WebSocket.OPEN) {
                                try {
                                    socket.send(JSON.stringify({
                                        type: 'set_route',
                                        payload: { waypoints: coords }
                                    }));
                                    console.log(`Route sent to server: ${coords.length} waypoints`);
                                } catch (sendError) {
                                    console.error('Error sending route to server:', sendError);
                                    alert('Warning: Could not send route to server. Route displayed but drone may not follow it.');
                                }
                            } else {
                                console.warn('WebSocket not connected, route not sent to server');
                                alert('Warning: WebSocket not connected. Route displayed but not sent to drone. Please check connection.');
                            }
                        } else {
                            console.error('Route API returned empty coordinates');
                            alert('Error: Could not generate route. Please try selecting a different destination.');
                        } 
                    } catch (err) { 
                        console.error('Route error:', err);
                        alert(`Route error: ${err.message}`); 
                    } 
                }
                
                function updateDroneLocation(lat, lon, signalQuality, stationsUsed, selectedStations) { 
                    clearWarningCircles(); 
                    droneLocation = { lat, lon }; 
                    pointA_coords.textContent = `${lat.toFixed(4)}, ${lon.toFixed(4)}`; 
                    
                    // Update signal bar
                    signal_bar.style.width = `${signalQuality || 0}%`;
                    signal_bar.style.background = signalQuality > 60 
                        ? 'linear-gradient(90deg, #00cc66, #66ff99)' 
                        : signalQuality > 30 
                            ? 'linear-gradient(90deg, #ffaa00, #ffcc00)'
                            : 'linear-gradient(90deg, #ff4444, #ff6666)';
                    
                    // Update selected station IDs for display filtering
                    if (selectedStations && selectedStations.length > 0) {
                        selectedStationIds = new Set(selectedStations);
                        console.log(`Selected stations for trilateration: ${Array.from(selectedStationIds).join(', ')}`);
                    }
                    
                    // Update active stations display
                    if (stationsUsed && stationsUsed.length > 0) {
                        active_stations.textContent = stationsUsed.join(', ');
                    }
                    
                    if (!droneMarker) { 
                        droneMarker = new mapgl.Marker(map, { 
                            coordinates: [lon, lat], 
                            icon: './icons/drone.png', 
                            size: [48, 48] 
                        }); 
                    } else { 
                        droneMarker.setCoordinates([lon, lat]); 
                    } 
                    
                    // FIXED: Ensure route line persists during flight
                    // Re-render route line if it was destroyed or doesn't exist
                    if (!routeLine && currentRouteWaypoints && currentRouteWaypoints.length >= 2) {
                        const routeCoords = currentRouteWaypoints.map(c => {
                            if (c && typeof c.lon === 'number' && typeof c.lat === 'number' && 
                                !isNaN(c.lon) && !isNaN(c.lat)) {
                                return [c.lon, c.lat];
                            }
                            return null;
                        }).filter(c => c !== null);
                        if (routeCoords.length >= 2) {
                            renderRouteLine(routeCoords);
                        }
                    }
                    
                    // Smooth camera follow
                    map.setCenter([lon, lat], { duration: 300 });
                    
                    // Update visible stations near drone
                    if (stationsVisible) {
                        renderStationsNearDrone();
                    }
                }
                
                function clearWarningCircles() { 
                    warningCircles.forEach(c => c.destroy()); 
                    warningCircles = []; 
                }
                
                // WebSocket connection
                function connectWebSocket() {
                    console.log('Attempting to connect to WebSocket server...');
                    try {
                        socket = new WebSocket('ws://localhost:8765');
                        
                        socket.onopen = () => { 
                            console.log('WebSocket connected successfully');
                            server_status_span.textContent = "Connected"; 
                            server_status_span.className = "status-connected"; 
                        };
                        
                        socket.onmessage = (event) => { 
                            try {
                                const data = JSON.parse(event.data); 
                                
                                if (data.type === 'location_update') { 
                                    if (data.payload.lat && data.payload.lon) { 
                                        // Extract selected stations (preferred) or fallback to stations_used
                                        const selectedStations = data.payload.selected_stations || data.payload.stations_used || [];
                                        updateDroneLocation(
                                            data.payload.lat, 
                                            data.payload.lon,
                                            data.payload.signal_quality,
                                            data.payload.stations_used,
                                            selectedStations  // Pass selected stations for filtering
                                        ); 
                                    } 
                                } else if (data.type === 'warning_low_signal') { 
                                    clearWarningCircles(); 
                                    data.payload.forEach(t => warningCircles.push(new mapgl.Circle(map, { 
                                        coordinates: [t.lon, t.lat], 
                                        radius: t.radius, 
                                        color: 'rgba(255, 165, 0, 0.2)', 
                                        stroke: 'orange', 
                                        strokeWidth: 3 
                                    }))); 
                                }
                            } catch (err) {
                                console.error('Error parsing WebSocket message:', err);
                            }
                        };
                        
                        socket.onclose = (event) => { 
                            console.log('WebSocket closed:', event.code, event.reason);
                            server_status_span.textContent = "Disconnected"; 
                            server_status_span.className = "status-disconnected";
                            // Reconnect after 3 seconds
                            setTimeout(connectWebSocket, 3000);
                        };
                        
                        socket.onerror = (error) => { 
                            console.error('WebSocket error:', error);
                            server_status_span.textContent = "Connection Error"; 
                            server_status_span.className = "status-disconnected"; 
                        };
                    } catch (error) {
                        console.error('Failed to create WebSocket:', error);
                        server_status_span.textContent = "Connection Failed"; 
                        server_status_span.className = "status-disconnected";
                        // Retry after 3 seconds
                        setTimeout(connectWebSocket, 3000);
                    }
                }
                
                connectWebSocket();
                
                // Event handlers
                map.on('click', (event) => { 
                    const [lon, lat] = event.lngLat; 
                    endPoint = { lon, lat }; 
                    
                    if (endMarker) endMarker.destroy(); 
                    endMarker = new mapgl.Marker(map, { 
                        coordinates: [lon, lat], 
                        icon: './icons/finish.svg', 
                        size: [36, 36], 
                        anchor: [18, 36], 
                        label: { text: 'üéØ Destination', color: '#ff4444', fontSize: 12 } 
                    }); 
                    
                    pointB_coords.textContent = `${lat.toFixed(4)}, ${lon.toFixed(4)}`; 
                    
                    // IMPROVED: Use selected start location if available, otherwise intelligent fallback
                    let routeStart = null;
                    
                    // Priority 1: Use selected start location from dropdown
                    const selectedLocationId = startLocationSelect.value;
                    if (selectedLocationId) {
                        const selectedLoc = droneLocations.find(loc => loc.id === selectedLocationId);
                        if (selectedLoc) {
                            routeStart = { lat: selectedLoc.lat, lon: selectedLoc.lon };
                            console.log(`Using selected start location: ${selectedLoc.name}`);
                        }
                    }
                    
                    // Priority 2: Use current drone location if no selection
                    if (!routeStart && droneLocation) {
                        routeStart = droneLocation;
                        console.log('Using current drone position for route calculation');
                    }
                    
                    // Priority 3: Use start of current route if drone position not yet available
                    if (!routeStart && currentRouteWaypoints && currentRouteWaypoints.length > 0) {
                        routeStart = currentRouteWaypoints[0];
                        console.log('Using route start as fallback for route calculation');
                    }
                    
                    // Priority 4: Use map center as last resort
                    if (!routeStart) {
                        const center = map.getCenter();
                        routeStart = { lat: center[1], lon: center[0] };
                        console.log('Using map center as fallback for route calculation');
                        // Warn user to select a starting point
                        if (!selectedLocationId) {
                            alert('Please select a starting point (Point A) from the dropdown for accurate trajectory following.');
                        }
                    }
                    
                    // Check distance - reduced threshold from 10m to 1m to allow closer waypoints
                    const distance = calculateDistanceMeters(routeStart.lat, routeStart.lon, endPoint.lat, endPoint.lon);
                    
                    if (distance > 1.0) {
                        // Fetch route from start point to destination
                        fetchRoute(routeStart, endPoint);
                    } else {
                        // Points are too close - provide user feedback
                        console.warn('Destination too close to start point (< 1m), route not fetched');
                        alert('Destination is too close to the start point. Please select a destination further away (at least 1 meter).');
                    }
                    
                    // Remind user to select starting point if not selected
                    if (!startLocationSelect.value) {
                        console.log('Route will use fallback starting point. Consider selecting a starting location for better accuracy.');
                    }
                });
                
                startDemoButton.addEventListener('click', () => {
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({ type: 'start_demo' }));
                    }
                });
                
                resetButton.addEventListener('click', () => { 
                    droneLocation = null; 
                    endPoint = null; 
                    currentRouteWaypoints = [];
                    
                    if (droneMarker) droneMarker.destroy(); 
                    if (endMarker) endMarker.destroy(); 
                    if (routeLine) routeLine.destroy(); 
                    intersectionMarkers.forEach(m => m.destroy()); 
                    clearWarningCircles(); 
                    
                    droneMarker = endMarker = routeLine = null; 
                    intersectionMarkers = []; 
                    
                    pointA_coords.textContent = 'Waiting...'; 
                    pointB_coords.textContent = 'Not set'; 
                    route_length_span.textContent = '0 m'; 
                    maneuvers_list.innerHTML = '<li>No route</li>'; 
                    intersection_count_span.textContent = '0'; 
                    intersection_points_list.innerHTML = ''; 
                    signal_bar.style.width = '0%';
                    active_stations.textContent = '-';
                    selectedStartLocation.textContent = '';
                    startLocationSelect.value = '';
                    setStartLocationButton.disabled = true;
                    
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({ type: 'stop' }));
                    }
                });
                
                toggleStationsButton.addEventListener('click', () => { 
                    stationsVisible = !stationsVisible; 
                    if (stationsVisible) {
                        renderStationsNearDrone();
                    } else {
                        stationMarkers.forEach(m => m.destroy());
                        stationCircles.forEach(c => c.destroy());
                        stationMarkers = [];
                        stationCircles = [];
                    }
                    toggleStationsButton.textContent = stationsVisible ? 'Hide Stations' : 'Show Stations'; 
                });
                
                // Initial render (empty until drone position is known)
                renderStationsNearDrone();
            }); // End of waitForMapgl callback
        }); // End of DOMContentLoaded
    </script>
</body>
</html>
